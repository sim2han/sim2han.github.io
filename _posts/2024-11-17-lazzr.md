---
layout: post
title: "lazzr: simple bevy shooting game"
description: "bevy를 활용한 슈팅 게임 데모 제작"
tags: [rust]
categories: [project]
---

![alt text](/images/posts/lazzr/thumbnail.png)

[[github]](https://github.com/sim2han/lazzr)

### 요약

Rust의 게임 엔진인 bevy를 통해 ECS 구조의 게임을 제작한다.

## 서론

Rust는 메모리 안정성을 추구한 언어로 쓰레기 수집 대신 소유권이라는 개념으로 메모리를 관리한다. C++의 문제를 개선한 언어라는 평이 눈에 띄어 배워보기로 했고, 취미 삼아 그것으로 게임을 제작해보기로 했다.

## bevy

Rust에는 클래스, 상속이 없다. 그래서 Rust로 만들어진 엔진은 다른 게임 엔진과 다른 모습을 띄는데, bevy는 그중 가장 유명한 엔진으로 ECS 구조를 사용한다.

ECS는 Entity, Component, System의 약자다. Entity는 말 그대로 게임 내의 물체를 뜻하고, Component는 Entity를 구성하는 속성, System은 특정 Component에 대해 작동하는 게임의 동작을 의미한다.

![alt text](/images/posts/lazzr/ecs.png)

엔진에서 Entity와 Component는 격자모양 데이터 집합으로 저장되고, Entity는 단순히 특정 Component의 모임을 뜻하는 숫자값으로 표현된다. System은 저 Component에서 자신이 원하는 부분을 쿼리하고 그에 일관된 동작을 처리한다.

예를 들어 모든 적의 HP를 10 줄이는 System을 작성한다면, 엔진은 System에게 Enemy와 HP Component를 지닌 모든 Entity에 대한 반복자를 전달하고, System은 그것으로 동작을 수행한다.

````
fn damage_enemy(
    mut query: Query<&mut Hp, With<Enemy>>,
) {
    for mut hp in query.iter_mut() {
        hp.damage(10);
    }
}
````

이 과정에서 장점이 생기는데, System이 처리하고자 하는 Component가 메모리에 연속적인 형태로 존재하기 때문에 성능 향상을 기대할 수 있고, 한 System이 접근하는 Component는 정해져 있기에, 여러 개의 겹치지 않는 System을 동시에 실행할 수 있다. 또한 이런 접근으로 인해 대규모 시뮬레이션에 강점을 가진다. 이외에 ECS를 사용하는 유명한 예로 Unity DOTS가 있다.

## 개발

Rust 학습을 위해 만드는 만큼 구성요소로 플레이어, 총알, 적, 벽 정도로 간단하게 제작하기로 했다.

어떤 Entity가 특정 Component를 가지고 있다는 것은 그 Component에 대한 동작을 수행한다는 뜻이다. 동시에 System은 그 Component를 쿼리해 동작을 시킨다. 이때, Entity 개인에게 동작을 정의하기 위한 Marker Component가 필요할 수 있다. 예를 들어 CameraMarker는 이 Entity가 카메라라는 것을 표현하기 위한 빈 컴포넌트이며, 이것을 가진 Entity는 카메라로 동작할 것이다. PlayerMarker도 마찮가지다.

그 외의 컴포넌트는 재사용이 쉬워야한다. 적, 플레이어, 카메라는 모두 Transform Component를 가지고, Transform에 대해 동일한 동작을 수행한다. 이를 위해 게임 구성요소에서 중복될 수 있는 속성을 찾아냈다.

````
#[derive(Component)]
pub struct LinearMove(pub Vec3);

pub fn update(mut objs: Query<(&mut Transform, &LinearMove)>, time: Res<Time>) {
    for (mut tr, linear) in objs.iter_mut() {
        tr.translation += linear.0 * time.delta_seconds();
    }
}
````

예를 들어 게임에는 직선으로 움직이는 총알과, 직선으로 움직이는 적이 존재한다. 이 둘은 (Bullet, LinearMove), (Enemy, LinearMove)로 동일한 속성을 넣어 표현이 가능하다. 뿐만 아니라 추후 직선으로 움직이는 다른 것이 필요해져도 쉽게 기능을 추가할 수 있다.

````
fn build(&self, commands: &mut Commands, asset_server: &Res<AssetServer>) {
    commands.spawn((
        SpriteBundle {
            texture: asset_server.load("sprite/square.png"),
            sprite: Sprite {
                color: Color::srgb(10.0, 0.0, 10.0),
                ..default()
            },
            ..default()
        },
        super::BulletMarker,
        AutoBullet,
        Projectile,
        MoveToPlayer(300.0),
        DespawnWhenOutWall,
        DespawnWithTime(5.0),
        CircleShape::from_radius(1.0),
        OnGameScreen,
    ));
}
````

Component를 모아 유도 총알을 구성하는 예시

그 외에도 bevy의 ui, 사운드 등 다양한 기능을 이용해 간단한 데모를 만들어 보았다.

### ECS에 대한 감상

Unity, Unreal만 접해본 나에게 rust, bevy, ECS는 매우 신선한 경험이었다.

Component와 System을 분리하는 방식은 게임 내부에 커플링을 줄이고, 재사용성을 늘리고, 멀티스레딩 환경에서도 이점을 가진다. 또한 데이터 지향적인 구조는 많은 성능향상을 꽤할 수 있다. 하지만 이것은 속성과 행위를 결합하는 객체와 반대되고, 기능이 계속 수평적으로 확장되는 특성상 설계가 굉장히 난해했다. 개발 초기에는 모든 오브젝트가 자신만의 Marker를 가져 재사용성을 살릴 수 없기도 했다. 그래서 이런 경험을 하며 구조를 생각하는 새로운 시점을 보게 되었고, 비슷한 구조를 사용하게 될 때 좋은 경험이 될거라 생각했다.

### Rust에 대한 감상

Rust에는 immutable, Option, Pattern Matching등 재밌는 기능이 많지만, 언어의 가장 중심에 있는건 소유권의 개념이다. Rust의 모든 값은 하나의 변수만이 소유할 수 있고, 나머지는 그것을 빌려 사용한다. 이를 통해 Rust 컴파일러는 변수가 언제 생성되고 사라지는지를 컴파일 시점에 모두 추적할 수 있고, 문제가 생길 수 있는 코드를 컴파일 에러로 거부한다.

처음에는 mut와 컴파일 에러가 증식하는 괴로운 경험이었지만, 사용하면서 오히려 모든 변수를 immutable로 설정하는게 안전한 코드를 작성하는데 도움이 된다고 느꼈다. let으로 shadowing하면서 변수를 선언하며 사용하는 것으로 코드를 더 간결하게 짤 수 있고, 패턴 매칭과 에러 처리를 강제하는 구조도 마치 언어가 개발자를 안전하게 코칭하는 것 처럼 느껴졌다.

최신 C++에서도 Rust의 이런 기능을 추가하려는 부분이 종종 보이는데, 앞으로 다른 언어를 사용할 때도 안전한 코드를 작성하게 하는데 도움이 될거라 생각한다.
